{"remainingRequest":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/babel-loader/lib/index.js!/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js??ref--13-0!/Users/sekiguchikeita/Desktop/sinapse_prototype/src/components/flowchart/render.js","dependencies":[{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/src/components/flowchart/render.js","mtime":1598506599000},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/cache-loader/dist/cjs.js","mtime":1598501629025},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/babel-loader/lib/index.js","mtime":1598501423176},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js","mtime":1598501658396}],"contextDependencies":[],"result":["// import * as d3 from 'd3';\n// import {roundTo20} from '../../utils/math';\n// function render(g, node, isSelected) {\n//   node.width = node.width || 120;\n//   node.height = node.height || 60;\n//   let borderColor = isSelected ? '#666666' : '#bbbbbb';\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     // title\n//     g.append('rect').\n//         attr('x', node.x).\n//         attr('y', node.y).\n//         attr('stroke', borderColor).\n//         attr('class', 'title').\n//         style('height', '20px').\n//         style('fill', '#f1f3f4').\n//         style('stroke-width', '1px').\n//         style('width', node.width + 'px');\n//     g.append('text').\n//         attr('x', node.x + 4).\n//         attr('y', node.y + 15).\n//         attr('class', 'unselectable').\n//         text(() => node.name).\n//         each(function wrap() {\n//           let self = d3.select(this),\n//               textLength = self.node().getComputedTextLength(),\n//               text = self.text();\n//           while (textLength > (node.width - 2 * 4) && text.length > 0) {\n//             text = text.slice(0, -1);\n//             self.text(text + '...');\n//             textLength = self.node().getComputedTextLength();\n//           }\n//         });\n//   }\n//   // body\n//   let body = g.append('rect').attr('class', 'body');\n//   body.style('width', node.width + 'px').\n//       style('fill', 'white').\n//       style('stroke-width', '1px');\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     body.attr('x', node.x).attr('y', node.y + 20);\n//     body.style('height', roundTo20(node.height - 20) + 'px');\n//   } else {\n//     body.attr('x', node.x).\n//         attr('y', node.y).\n//         classed(node.type, true).\n//         attr('rx', 30);\n//     body.style('height', roundTo20(node.height) + 'px');\n//   }\n//   body.attr('stroke', borderColor);\n//   // body text\n//   let text = node.type === 'start'\n//       ? 'Start'\n//       : (node.type === 'end' ? 'End' : (\n//               (!node.approvers || node.approvers.length === 0)\n//                   ? 'No approver'\n//                   : (\n//                       node.approvers.length > 1\n//                           ? `${node.approvers[0].name + '...'}`\n//                           : node.approvers[0].name\n//                   )\n//           )\n//       );\n//   let bodyTextY;\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     bodyTextY = node.y + 25 + roundTo20(node.height - 20) / 2;\n//   } else {\n//     bodyTextY = node.y + 5 + roundTo20(node.height) / 2;\n//   }\n//   g.append('text').\n//       attr('x', node.x + node.width / 2).\n//       attr('y', bodyTextY).\n//       attr('class', 'unselectable').\n//       attr('text-anchor', 'middle').\n//       text(function() {return text;}).each(function wrap() {\n//     let self = d3.select(this),\n//         textLength = self.node().getComputedTextLength(),\n//         text = self.text();\n//     while (textLength > (node.width - 2 * 4) && text.length > 0) {\n//       text = text.slice(0, -1);\n//       self.text(text + '...');\n//       textLength = self.node().getComputedTextLength();\n//     }\n//   });\n// }\n// export default render;",{"version":3,"sources":["/Users/sekiguchikeita/Desktop/sinapse_prototype/src/components/flowchart/render.js"],"names":[],"mappings":"AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// import * as d3 from 'd3';\n// import {roundTo20} from '../../utils/math';\n\n// function render(g, node, isSelected) {\n//   node.width = node.width || 120;\n//   node.height = node.height || 60;\n//   let borderColor = isSelected ? '#666666' : '#bbbbbb';\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     // title\n//     g.append('rect').\n//         attr('x', node.x).\n//         attr('y', node.y).\n//         attr('stroke', borderColor).\n//         attr('class', 'title').\n//         style('height', '20px').\n//         style('fill', '#f1f3f4').\n//         style('stroke-width', '1px').\n//         style('width', node.width + 'px');\n//     g.append('text').\n//         attr('x', node.x + 4).\n//         attr('y', node.y + 15).\n//         attr('class', 'unselectable').\n//         text(() => node.name).\n//         each(function wrap() {\n//           let self = d3.select(this),\n//               textLength = self.node().getComputedTextLength(),\n//               text = self.text();\n//           while (textLength > (node.width - 2 * 4) && text.length > 0) {\n//             text = text.slice(0, -1);\n//             self.text(text + '...');\n//             textLength = self.node().getComputedTextLength();\n//           }\n//         });\n//   }\n//   // body\n//   let body = g.append('rect').attr('class', 'body');\n//   body.style('width', node.width + 'px').\n//       style('fill', 'white').\n//       style('stroke-width', '1px');\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     body.attr('x', node.x).attr('y', node.y + 20);\n//     body.style('height', roundTo20(node.height - 20) + 'px');\n//   } else {\n//     body.attr('x', node.x).\n//         attr('y', node.y).\n//         classed(node.type, true).\n//         attr('rx', 30);\n//     body.style('height', roundTo20(node.height) + 'px');\n//   }\n//   body.attr('stroke', borderColor);\n\n//   // body text\n//   let text = node.type === 'start'\n//       ? 'Start'\n//       : (node.type === 'end' ? 'End' : (\n//               (!node.approvers || node.approvers.length === 0)\n//                   ? 'No approver'\n//                   : (\n//                       node.approvers.length > 1\n//                           ? `${node.approvers[0].name + '...'}`\n//                           : node.approvers[0].name\n//                   )\n//           )\n//       );\n//   let bodyTextY;\n//   if (node.type !== 'start' && node.type !== 'end') {\n//     bodyTextY = node.y + 25 + roundTo20(node.height - 20) / 2;\n//   } else {\n//     bodyTextY = node.y + 5 + roundTo20(node.height) / 2;\n//   }\n//   g.append('text').\n//       attr('x', node.x + node.width / 2).\n//       attr('y', bodyTextY).\n//       attr('class', 'unselectable').\n//       attr('text-anchor', 'middle').\n//       text(function() {return text;}).each(function wrap() {\n//     let self = d3.select(this),\n//         textLength = self.node().getComputedTextLength(),\n//         text = self.text();\n//     while (textLength > (node.width - 2 * 4) && text.length > 0) {\n//       text = text.slice(0, -1);\n//       self.text(text + '...');\n//       textLength = self.node().getComputedTextLength();\n//     }\n//   });\n// }\n\n// export default render;\n"]}]}