{"remainingRequest":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/babel-loader/lib/index.js!/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/sekiguchikeita/Desktop/sinapse_prototype/src/components/flowchart/Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/src/components/flowchart/Flowchart.vue","mtime":1598506599000},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/cache-loader/dist/cjs.js","mtime":1598501629025},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/babel-loader/lib/index.js","mtime":1598501423176},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/cache-loader/dist/cjs.js","mtime":1598501629025},{"path":"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/vue-loader/lib/index.js","mtime":1598501639569}],"contextDependencies":[],"result":["import _typeof from \"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.math.hypot\";\nimport _toConsumableArray from \"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.math.trunc\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/sekiguchikeita/Desktop/sinapse_prototype/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { line2, lineTo } from \"../../utils/svg\";\nimport * as d3 from \"d3\";\nimport { between, distanceOfPointToLine, getEdgeOfPoints, pointRectangleIntersection } from \"../../utils/math\";\nimport render from \"./render\";\nexport default {\n  name: \"flowchart\",\n  props: {\n    nodes: {\n      type: Array,\n      default: function _default() {\n        return [{\n          id: 1,\n          x: 140,\n          y: 270,\n          name: \"Start\",\n          thumbnail: \"start\"\n        }, {\n          id: 2,\n          x: 540,\n          y: 270,\n          name: \"End\",\n          thumbnail: \"end\"\n        }];\n      }\n    },\n    connections: {\n      type: Array,\n      default: function _default() {\n        return [{\n          source: {\n            id: 1,\n            position: \"right\"\n          },\n          destination: {\n            id: 2,\n            position: \"left\"\n          },\n          id: 1,\n          type: \"pass\"\n        }];\n      }\n    },\n    width: {\n      type: [String, Number],\n      // default: 800,\n      // default: '60%',\n      default: '100%'\n    },\n    height: {\n      type: [String, Number],\n      // default: 600,\n      default: '100%'\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    },\n    render: {\n      type: Function,\n      default: render\n    }\n  },\n  data: function data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: {\n        x: 0,\n        y: 0\n      },\n      clickedOnce: false,\n      pathClickedOnce: false,\n\n      /**\n       *  of all internalConnections\n       */\n      lines: []\n    };\n  },\n  methods: {\n    add: function add(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.internalNodes.push(node);\n    },\n    editCurrent: function editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode: function editNode(node) {\n      if (this.readonly) {\n        return;\n      } // @editnode=\"handleEditNode\"に引数nodeを渡して実行\n\n\n      this.$emit(\"editnode\", node);\n    },\n    editConnection: function editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel: function handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (event.ctrlKey) {\n        var svg = document.getElementById(\"svg\");\n        var zoom = parseFloat(svg.style.zoom || 1);\n\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    handleChartMouseUp: function () {\n      var _handleChartMouseUp = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var tempId, conn;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.connectingInfo.source) {\n                  if (this.hoveredConnector) {\n                    if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n                      // Node can't connect to itself\n                      tempId = +new Date();\n                      conn = {\n                        source: {\n                          id: this.connectingInfo.source.id,\n                          position: this.connectingInfo.sourcePosition\n                        },\n                        destination: {\n                          id: this.hoveredConnector.node.id,\n                          position: this.hoveredConnector.position\n                        },\n                        id: tempId,\n                        type: \"pass\",\n                        name: \"Pass\"\n                      };\n                      this.internalConnections.push(conn);\n                    }\n                  } // 初期化\n\n\n                  this.connectingInfo.source = null;\n                  this.connectingInfo.sourcePosition = null;\n                }\n\n                if (this.selectionInfo) {\n                  this.selectionInfo = null;\n                }\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChartMouseUp() {\n        return _handleChartMouseUp.apply(this, arguments);\n      }\n\n      return handleChartMouseUp;\n    }(),\n    handleChartMouseMove: function () {\n      var _handleChartMouseMove = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(event) {\n        var boundingClientRect, actualX, actualY, sourceOffset, destinationPosition;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // calc offset of cursor to chart\n                boundingClientRect = event.currentTarget.getBoundingClientRect(); // actualX = ページの左上からの座標 - チャートの左側までの座標 - windowを正の方向にスクロースしている座標;\n\n                actualX = event.pageX - boundingClientRect.left - window.scrollX;\n                this.cursorToChartOffset.x = Math.trunc(actualX);\n                actualY = event.pageY - boundingClientRect.top - window.scrollY;\n                this.cursorToChartOffset.y = Math.trunc(actualY); // connectionを接続中ならば\n\n                if (!this.connectingInfo.source) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                _context2.next = 8;\n                return this.renderConnections();\n\n              case 8:\n                d3.selectAll(\"#svg .connector\").classed(\"active\", true);\n                sourceOffset = this.getNodeConnectorOffset(this.connectingInfo.source.id, this.connectingInfo.sourcePosition);\n                destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n                this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x, this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, destinationPosition);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleChartMouseMove(_x) {\n        return _handleChartMouseMove.apply(this, arguments);\n      }\n\n      return handleChartMouseMove;\n    }(),\n    handleChartDblClick: function handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"dblclick\", {\n        x: event.offsetX,\n        y: event.offsetY\n      });\n    },\n    handleChartMouseDown: function handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n\n      this.selectionInfo = {\n        x: event.offsetX,\n        y: event.offsetY\n      };\n    },\n    // ここでコネクターの位置を調整できる\n    getConnectorPosition: function getConnectorPosition(node) {\n      var halfWidth = node.width / 2;\n      var halfHeight = node.height / 2;\n      var top = {\n        x: node.x + halfWidth,\n        y: node.y\n      };\n      var left = {\n        x: node.x,\n        y: node.y + halfHeight\n      };\n      var bottom = {\n        x: node.x + halfWidth,\n        y: node.y + node.height\n      };\n      var right = {\n        x: node.x + node.width,\n        y: node.y + halfHeight\n      };\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    },\n    // chart上で選択範囲を描画\n    renderSelection: function renderSelection() {\n      var that = this; // render selection rectangle\n\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        var edge = getEdgeOfPoints([{\n          x: that.selectionInfo.x,\n          y: that.selectionInfo.y\n        }, {\n          x: that.cursorToChartOffset.x,\n          y: that.cursorToChartOffset.y\n        }]);\n        var svg = d3.select(\"#svg\");\n        var rect = svg.select(\".selection\").classed(\"active\", true);\n        rect.attr(\"x\", edge.start.x).attr(\"y\", edge.start.y).attr(\"width\", edge.end.x - edge.start.x).attr(\"height\", edge.end.y - edge.start.y);\n        that.internalNodes.forEach(function (item) {\n          var points = [{\n            x: item.x,\n            y: item.y\n          }, {\n            x: item.x,\n            y: item.y + item.height\n          }, {\n            x: item.x + item.width,\n            y: item.y\n          }, {\n            x: item.x + item.width,\n            y: item.y + item.height\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          })) {\n            // currentNodes = 選択nodes\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach(function (line) {\n          var points = [{\n            x: line.sourceX,\n            y: line.sourceY\n          }, {\n            x: line.destinationX,\n            y: line.destinationY\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          }) && that.currentConnections.every(function (item) {\n            return item.id !== line.id;\n          })) {\n            var connection = that.internalConnections.filter(function (conn) {\n              return conn.id === line.id;\n            })[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        // 選択されたときはactiveクラスが付与される\n        d3.selectAll(\"#svg > .selection\").classed(\"active\", false);\n      }\n    },\n    renderConnections: function renderConnections() {\n      var that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          d3.selectAll(\"#svg > g.connection\").remove(); // render lines\n\n          that.lines = [];\n          that.internalConnections.forEach(function (conn) {\n            var sourcePosition = that.getNodeConnectorOffset(conn.source.id, conn.source.position);\n            var destinationPosition = that.getNodeConnectorOffset(conn.destination.id, conn.destination.position);\n            var colors = {\n              pass: \"#52c41a\",\n              reject: \"red\"\n            };\n\n            if (that.currentConnections.filter(function (item) {\n              return item === conn;\n            }).length > 0) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\"\n              };\n            }\n\n            var result = that.arrowTo(sourcePosition.x, sourcePosition.y, destinationPosition.x, destinationPosition.y, conn.source.position, conn.destination.position, colors[conn.type], // 追加\n            conn.name);\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = result.paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var path = _step.value;\n                path.on(\"mousedown\", function () {\n                  d3.event.stopPropagation();\n\n                  if (that.pathClickedOnce) {\n                    that.editConnection(conn);\n                  } else {\n                    var timer = setTimeout(function () {\n                      that.pathClickedOnce = false;\n                      clearTimeout(timer);\n                    }, 300);\n                    that.pathClickedOnce = true;\n                  }\n\n                  that.currentNodes.splice(0, that.currentNodes.length);\n                  that.currentConnections.splice(0, that.currentConnections.length);\n                  that.currentConnections.push(conn);\n                });\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = result.lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var line = _step2.value;\n                that.lines.push({\n                  sourceX: line.sourceX,\n                  sourceY: line.sourceY,\n                  destinationX: line.destinationX,\n                  destinationY: line.destinationY,\n                  id: conn.id\n                });\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes: function renderNodes() {\n      var that = this;\n      return new Promise(function (resolve) {\n        d3.selectAll(\"#svg > g.node\").remove(); // render nodes\n\n        that.internalNodes.forEach(function (node) {\n          that.renderNode(node, that.currentNodes.filter(function (item) {\n            return item === node;\n          }).length > 0);\n        });\n        resolve();\n      });\n    },\n    getNodeConnectorOffset: function getNodeConnectorOffset(nodeId, connectorPosition) {\n      var node = this.internalNodes.filter(function (item) {\n        return item.id === nodeId;\n      })[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append: function append(element) {\n      var svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo: function guideLineTo(x1, y1, x2, y2) {\n      var g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo: function arrowTo(x1, y1, x2, y2, startPosition, endPosition, color, connName) {\n      var g = this.append(\"g\");\n      g.append('text').attr(\"fill\", \"#7CF8FD\").attr(\"x\", x2 + 10).attr(\"y\", y2 - 40).style(\"width\", 10 + \"px\").style(\"height\", 10 + \"px\").text(connName);\n      g.classed(\"connection\", true);\n      line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true); // a 5px cover to make mouse operation conveniently\n\n      return line2(g, x1, y1, x2, y2, startPosition, endPosition, 5, \"transparent\", false);\n    },\n    renderNode: function renderNode(node, isSelected) {\n      var that = this;\n      var g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      node.render = that.render;\n      node.render(g, node, isSelected);\n      var drag = d3.drag().on(\"start\", function () {\n        // handle mousedown\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentConnections.splice(0, that.currentConnections.length);\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentNodes.push(node);\n        }\n\n        if (that.clickedOnce) {\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.editNode(node);\n        } else {\n          var timer = setTimeout(function () {\n            that.clickedOnce = false;\n            clearTimeout(timer);\n          }, 300);\n          that.clickedOnce = true;\n        }\n      }).on(\"drag\",\n      /*#__PURE__*/\n      _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3() {\n        var zoom, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, currentNode, edge, expectX, expectY;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!that.readonly) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n                _iteratorNormalCompletion3 = true;\n                _didIteratorError3 = false;\n                _iteratorError3 = undefined;\n                _context3.prev = 6;\n\n                for (_iterator3 = that.currentNodes[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  currentNode = _step3.value;\n                  currentNode.x += d3.event.dx / zoom;\n                  currentNode.y += d3.event.dy / zoom;\n                }\n\n                _context3.next = 14;\n                break;\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](6);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context3.t0;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.prev = 15;\n\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n\n              case 17:\n                _context3.prev = 17;\n\n                if (!_didIteratorError3) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 20:\n                return _context3.finish(17);\n\n              case 21:\n                return _context3.finish(14);\n\n              case 22:\n                d3.selectAll(\"#svg > g.guideline\").remove();\n                edge = that.getCurrentNodesEdge();\n                expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n                expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n                that.internalNodes.forEach(function (item) {\n                  if (that.currentNodes.filter(function (currentNode) {\n                    return currentNode === item;\n                  }).length === 0) {\n                    if (item.x === expectX) {\n                      // vertical guideline\n                      if (item.y < expectY) {\n                        that.guideLineTo(item.x, item.y + item.height, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX, expectY + item.height, item.x, item.y);\n                      }\n                    }\n\n                    if (item.y === expectY) {\n                      // horizontal guideline\n                      if (item.x < expectX) {\n                        that.guideLineTo(item.x + item.width, item.y, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX + item.width, expectY, item.x, item.y);\n                      }\n                    }\n                  }\n                });\n\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[6, 10, 14, 22], [15,, 17, 21]]);\n      }))).on(\"end\", function () {\n        d3.selectAll(\"#svg > g.guideline\").remove();\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = that.currentNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var currentNode = _step4.value;\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n      var connectors = [];\n      var connectorPosition = this.getConnectorPosition(node);\n\n      var _loop = function _loop(position) {\n        var positionElement = connectorPosition[position];\n        var connector = g.append(\"circle\").attr(\"cx\", positionElement.x).attr(\"cy\", positionElement.y).attr(\"r\", 4).attr(\"class\", \"connector\");\n        connector.on(\"mousedown\", function () {\n          d3.event.stopPropagation();\n\n          if (node.type === \"end\" || that.readonly) {\n            return;\n          }\n\n          that.connectingInfo.source = node;\n          that.connectingInfo.sourcePosition = position;\n        }).on(\"mouseup\", function () {\n          d3.event.stopPropagation();\n\n          if (that.connectingInfo.source) {\n            if (that.connectingInfo.source.id !== node.id) {\n              // Node can't connect to itself\n              var tempId = +new Date();\n              var conn = {\n                source: {\n                  id: that.connectingInfo.source.id,\n                  position: that.connectingInfo.sourcePosition\n                },\n                destination: {\n                  id: node.id,\n                  position: position\n                },\n                id: tempId,\n                type: \"pass\",\n                name: \"Pass\"\n              };\n              that.internalConnections.push(conn);\n            }\n\n            that.connectingInfo.source = null;\n            that.connectingInfo.sourcePosition = null;\n          }\n        }).on(\"mouseover\", function () {\n          connector.classed(\"active\", true);\n        }).on(\"mouseout\", function () {\n          connector.classed(\"active\", false);\n        });\n        connectors.push(connector);\n      };\n\n      for (var position in connectorPosition) {\n        _loop(position);\n      }\n\n      g.on(\"mouseover\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", true);\n        });\n      }).on(\"mouseout\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", false);\n        });\n      });\n    },\n    getCurrentNodesEdge: function getCurrentNodesEdge() {\n      var points = this.currentNodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y\n        };\n      });\n      points.push.apply(points, _toConsumableArray(this.currentNodes.map(function (node) {\n        return {\n          x: node.x + node.width,\n          y: node.y + node.height\n        };\n      })));\n      return getEdgeOfPoints(points);\n    },\n    save: function save() {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"save\", this.internalNodes, this.internalConnections);\n    },\n    remove: function () {\n      var _remove = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4() {\n        var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, conn, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, node;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.readonly) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (!(this.currentConnections.length > 0)) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                _iteratorNormalCompletion5 = true;\n                _didIteratorError5 = false;\n                _iteratorError5 = undefined;\n                _context4.prev = 6;\n\n                for (_iterator5 = this.currentConnections[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                  conn = _step5.value;\n                  this.removeConnection(conn);\n                }\n\n                _context4.next = 14;\n                break;\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](6);\n                _didIteratorError5 = true;\n                _iteratorError5 = _context4.t0;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.prev = 15;\n\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n\n              case 17:\n                _context4.prev = 17;\n\n                if (!_didIteratorError5) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                throw _iteratorError5;\n\n              case 20:\n                return _context4.finish(17);\n\n              case 21:\n                return _context4.finish(14);\n\n              case 22:\n                this.currentConnections.splice(0, this.currentConnections.length);\n\n              case 23:\n                if (!(this.currentNodes.length > 0)) {\n                  _context4.next = 44;\n                  break;\n                }\n\n                _iteratorNormalCompletion6 = true;\n                _didIteratorError6 = false;\n                _iteratorError6 = undefined;\n                _context4.prev = 27;\n\n                for (_iterator6 = this.currentNodes[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                  node = _step6.value;\n                  this.removeNode(node);\n                }\n\n                _context4.next = 35;\n                break;\n\n              case 31:\n                _context4.prev = 31;\n                _context4.t1 = _context4[\"catch\"](27);\n                _didIteratorError6 = true;\n                _iteratorError6 = _context4.t1;\n\n              case 35:\n                _context4.prev = 35;\n                _context4.prev = 36;\n\n                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                  _iterator6.return();\n                }\n\n              case 38:\n                _context4.prev = 38;\n\n                if (!_didIteratorError6) {\n                  _context4.next = 41;\n                  break;\n                }\n\n                throw _iteratorError6;\n\n              case 41:\n                return _context4.finish(38);\n\n              case 42:\n                return _context4.finish(35);\n\n              case 43:\n                this.currentNodes.splice(0, this.currentNodes.length);\n\n              case 44:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[6, 10, 14, 22], [15,, 17, 21], [27, 31, 35, 43], [36,, 38, 42]]);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    removeNode: function removeNode(node) {\n      var connections = this.internalConnections.filter(function (item) {\n        return item.source.id === node.id || item.destination.id === node.id;\n      });\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = connections[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var connection = _step7.value;\n          this.internalConnections.splice(this.internalConnections.indexOf(connection), 1);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection: function removeConnection(conn) {\n      var index = this.internalConnections.indexOf(conn);\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode: function moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = this.currentNodes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var node = _step8.value;\n            node.x += x;\n            node.y += y;\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n    },\n    init: function init() {\n      var that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach(function (node) {\n        var newNode = Object.assign({}, node);\n        newNode.width = newNode.width || 400;\n        newNode.height = newNode.height || 200;\n        that.internalNodes.push(newNode);\n      });\n      that.connections.forEach(function (connection) {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    }\n  },\n  mounted: function mounted() {\n    var that = this;\n    that.init(); // 十字キーによる移動\n\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            var _that$currentNodes, _that$currentConnecti;\n\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n\n            (_that$currentNodes = that.currentNodes).push.apply(_that$currentNodes, _toConsumableArray(that.internalNodes));\n\n            (_that$currentConnecti = that.currentConnections).push.apply(_that$currentConnecti, _toConsumableArray(that.internalConnections));\n\n            event.preventDefault();\n          }\n\n          break;\n\n        case 46:\n          that.remove();\n          break;\n\n        default:\n          break;\n      }\n    };\n  },\n  created: function created() {},\n  computed: {\n    hoveredConnector: function hoveredConnector() {\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this.internalNodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var node = _step9.value;\n          var connectorPosition = this.getConnectorPosition(node);\n\n          for (var prop in connectorPosition) {\n            var entry = connectorPosition[prop];\n\n            if (Math.hypot(entry.x - this.cursorToChartOffset.x, entry.y - this.cursorToChartOffset.y) < 10) {\n              return {\n                position: prop,\n                node: node\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      return null;\n    },\n    hoveredConnection: function hoveredConnection() {\n      var _this = this;\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var line = _step10.value;\n          var distance = distanceOfPointToLine(line.sourceX, line.sourceY, line.destinationX, line.destinationY, _this.cursorToChartOffset.x, _this.cursorToChartOffset.y);\n\n          if (distance < 5 && between(line.sourceX - 2, line.destinationX + 2, _this.cursorToChartOffset.x) && between(line.sourceY - 2, line.destinationY + 2, _this.cursorToChartOffset.y)) {\n            var connections = _this.internalConnections.filter(function (item) {\n              return item.id === line.id;\n            });\n\n            return {\n              v: connections.length > 0 ? connections[0] : null\n            };\n          }\n        };\n\n        for (var _iterator10 = this.lines[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _ret = _loop2();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return null;\n    },\n    cursor: function cursor() {\n      // connectorをhover時とコネクター選択時は十字キーになる\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n\n      return null;\n    }\n  },\n  watch: {\n    internalNodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderNodes();\n        this.renderConnections();\n      }\n    },\n    internalConnections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderSelection();\n      }\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderNodes();\n      }\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      }\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.renderConnections();\n      }\n    },\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.init();\n      }\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler: function handler() {\n        this.init();\n      }\n    }\n  }\n};",{"version":3,"sources":["Flowchart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,SAAA,KAAA,EAAA,MAAA;AACA,OAAA,KAAA,EAAA,MAAA,IAAA;AACA,SACA,OADA,EAEA,qBAFA,EAGA,eAHA,EAIA,0BAJA;AAMA,OAAA,MAAA;AAEA,eAAA;AACA,EAAA,IAAA,EAAA,WADA;AAEA,EAAA,KAAA,EAAA;AACA,IAAA,KAAA,EAAA;AACA,MAAA,IAAA,EAAA,KADA;AAEA,MAAA,OAAA,EAAA;AAAA,eAAA,CACA;AAAA,UAAA,EAAA,EAAA,CAAA;AAAA,UAAA,CAAA,EAAA,GAAA;AAAA,UAAA,CAAA,EAAA,GAAA;AAAA,UAAA,IAAA,EAAA,OAAA;AAAA,UAAA,SAAA,EAAA;AAAA,SADA,EAEA;AAAA,UAAA,EAAA,EAAA,CAAA;AAAA,UAAA,CAAA,EAAA,GAAA;AAAA,UAAA,CAAA,EAAA,GAAA;AAAA,UAAA,IAAA,EAAA,KAAA;AAAA,UAAA,SAAA,EAAA;AAAA,SAFA,CAAA;AAAA;AAFA,KADA;AAQA,IAAA,WAAA,EAAA;AACA,MAAA,IAAA,EAAA,KADA;AAEA,MAAA,OAAA,EAAA;AAAA,eAAA,CACA;AACA,UAAA,MAAA,EAAA;AAAA,YAAA,EAAA,EAAA,CAAA;AAAA,YAAA,QAAA,EAAA;AAAA,WADA;AAEA,UAAA,WAAA,EAAA;AAAA,YAAA,EAAA,EAAA,CAAA;AAAA,YAAA,QAAA,EAAA;AAAA,WAFA;AAGA,UAAA,EAAA,EAAA,CAHA;AAIA,UAAA,IAAA,EAAA;AAJA,SADA,CAAA;AAAA;AAFA,KARA;AAmBA,IAAA,KAAA,EAAA;AACA,MAAA,IAAA,EAAA,CAAA,MAAA,EAAA,MAAA,CADA;AAEA;AACA;AACA,MAAA,OAAA,EAAA;AAJA,KAnBA;AAyBA,IAAA,MAAA,EAAA;AACA,MAAA,IAAA,EAAA,CAAA,MAAA,EAAA,MAAA,CADA;AAEA;AACA,MAAA,OAAA,EAAA;AAHA,KAzBA;AA8BA,IAAA,QAAA,EAAA;AACA,MAAA,IAAA,EAAA,OADA;AAEA,MAAA,OAAA,EAAA;AAFA,KA9BA;AAkCA,IAAA,MAAA,EAAA;AACA,MAAA,IAAA,EAAA,QADA;AAEA,MAAA,OAAA,EAAA;AAFA;AAlCA,GAFA;AAyCA,EAAA,IAzCA,kBAyCA;AACA,WAAA;AACA,MAAA,aAAA,EAAA,EADA;AAEA,MAAA,mBAAA,EAAA,EAFA;AAGA,MAAA,cAAA,EAAA;AACA,QAAA,MAAA,EAAA,IADA;AAEA,QAAA,cAAA,EAAA;AAFA,OAHA;AAOA,MAAA,aAAA,EAAA,IAPA;AAQA,MAAA,YAAA,EAAA,EARA;AASA,MAAA,kBAAA,EAAA,EATA;;AAUA;;;AAGA,MAAA,mBAAA,EAAA;AAAA,QAAA,CAAA,EAAA,CAAA;AAAA,QAAA,CAAA,EAAA;AAAA,OAbA;AAcA,MAAA,WAAA,EAAA,KAdA;AAeA,MAAA,eAAA,EAAA,KAfA;;AAgBA;;;AAGA,MAAA,KAAA,EAAA;AAnBA,KAAA;AAqBA,GA/DA;AAgEA,EAAA,OAAA,EAAA;AACA,IAAA,GADA,eACA,IADA,EACA;AACA,UAAA,KAAA,QAAA,EAAA;AACA;AACA;;AACA,WAAA,aAAA,CAAA,IAAA,CAAA,IAAA;AACA,KANA;AAOA,IAAA,WAPA,yBAOA;AACA,UAAA,KAAA,YAAA,CAAA,MAAA,KAAA,CAAA,EAAA;AACA,aAAA,QAAA,CAAA,KAAA,YAAA,CAAA,CAAA,CAAA;AACA,OAFA,MAEA,IAAA,KAAA,kBAAA,CAAA,MAAA,KAAA,CAAA,EAAA;AACA,aAAA,cAAA,CAAA,KAAA,kBAAA,CAAA,CAAA,CAAA;AACA;AACA,KAbA;AAcA,IAAA,QAdA,oBAcA,IAdA,EAcA;AACA,UAAA,KAAA,QAAA,EAAA;AACA;AACA,OAHA,CAIA;;;AACA,WAAA,KAAA,CAAA,UAAA,EAAA,IAAA;AACA,KApBA;AAqBA,IAAA,cArBA,0BAqBA,UArBA,EAqBA;AACA,UAAA,KAAA,QAAA,EAAA;AACA;AACA;;AACA,WAAA,KAAA,CAAA,gBAAA,EAAA,UAAA;AACA,KA1BA;AA2BA,IAAA,qBA3BA,iCA2BA,KA3BA,EA2BA;AACA,MAAA,KAAA,CAAA,eAAA;AACA,MAAA,KAAA,CAAA,cAAA;;AACA,UAAA,KAAA,CAAA,OAAA,EAAA;AACA,YAAA,GAAA,GAAA,QAAA,CAAA,cAAA,CAAA,KAAA,CAAA;AACA,YAAA,IAAA,GAAA,UAAA,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,IAAA,CAAA,CAAA;;AACA,YAAA,KAAA,CAAA,MAAA,GAAA,CAAA,IAAA,IAAA,KAAA,GAAA,EAAA;AACA;AACA;;AACA,QAAA,IAAA,IAAA,KAAA,CAAA,MAAA,GAAA,GAAA,GAAA,EAAA;AACA,QAAA,GAAA,CAAA,KAAA,CAAA,IAAA,GAAA,IAAA;AACA;AACA,KAvCA;AAwCA,IAAA,kBAxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCA,oBAAA,KAAA,cAAA,CAAA,MAAA,EAAA;AACA,sBAAA,KAAA,gBAAA,EAAA;AACA,wBAAA,KAAA,cAAA,CAAA,MAAA,CAAA,EAAA,KAAA,KAAA,gBAAA,CAAA,IAAA,CAAA,EAAA,EAAA;AACA;AACA,sBAAA,MAFA,GAEA,CAAA,IAAA,IAAA,EAFA;AAGA,sBAAA,IAHA,GAGA;AACA,wBAAA,MAAA,EAAA;AACA,0BAAA,EAAA,EAAA,KAAA,cAAA,CAAA,MAAA,CAAA,EADA;AAEA,0BAAA,QAAA,EAAA,KAAA,cAAA,CAAA;AAFA,yBADA;AAKA,wBAAA,WAAA,EAAA;AACA,0BAAA,EAAA,EAAA,KAAA,gBAAA,CAAA,IAAA,CAAA,EADA;AAEA,0BAAA,QAAA,EAAA,KAAA,gBAAA,CAAA;AAFA,yBALA;AASA,wBAAA,EAAA,EAAA,MATA;AAUA,wBAAA,IAAA,EAAA,MAVA;AAWA,wBAAA,IAAA,EAAA;AAXA,uBAHA;AAgBA,2BAAA,mBAAA,CAAA,IAAA,CAAA,IAAA;AACA;AACA,mBApBA,CAqBA;;;AACA,uBAAA,cAAA,CAAA,MAAA,GAAA,IAAA;AACA,uBAAA,cAAA,CAAA,cAAA,GAAA,IAAA;AACA;;AACA,oBAAA,KAAA,aAAA,EAAA;AACA,uBAAA,aAAA,GAAA,IAAA;AACA;;AApEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAsEA,IAAA,oBAtEA;AAAA;AAAA;AAAA,gDAsEA,KAtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuEA;AACA,gBAAA,kBAxEA,GAwEA,KAAA,CAAA,aAAA,CAAA,qBAAA,EAxEA,EAyEA;;AACA,gBAAA,OA1EA,GA0EA,KAAA,CAAA,KAAA,GAAA,kBAAA,CAAA,IAAA,GAAA,MAAA,CAAA,OA1EA;AA2EA,qBAAA,mBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAAA;AACA,gBAAA,OA5EA,GA4EA,KAAA,CAAA,KAAA,GAAA,kBAAA,CAAA,GAAA,GAAA,MAAA,CAAA,OA5EA;AA6EA,qBAAA,mBAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAAA,CA7EA,CA+EA;;AA/EA,qBAgFA,KAAA,cAAA,CAAA,MAhFA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAiFA,KAAA,iBAAA,EAjFA;;AAAA;AAmFA,gBAAA,EAAA,CAAA,SAAA,CAAA,iBAAA,EAAA,OAAA,CAAA,QAAA,EAAA,IAAA;AAEA,gBAAA,YArFA,GAqFA,KAAA,sBAAA,CACA,KAAA,cAAA,CAAA,MAAA,CAAA,EADA,EAEA,KAAA,cAAA,CAAA,cAFA,CArFA;AAyFA,gBAAA,mBAzFA,GAyFA,KAAA,gBAAA,GACA,KAAA,gBAAA,CAAA,QADA,GAEA,IA3FA;AA4FA,qBAAA,OAAA,CACA,YAAA,CAAA,CADA,EAEA,YAAA,CAAA,CAFA,EAGA,KAAA,mBAAA,CAAA,CAHA,EAIA,KAAA,mBAAA,CAAA,CAJA,EAKA,KAAA,cAAA,CAAA,cALA,EAMA,mBANA;;AA5FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAsGA,IAAA,mBAtGA,+BAsGA,KAtGA,EAsGA;AACA,UAAA,KAAA,QAAA,EAAA;AACA;AACA;;AACA,WAAA,KAAA,CAAA,UAAA,EAAA;AAAA,QAAA,CAAA,EAAA,KAAA,CAAA,OAAA;AAAA,QAAA,CAAA,EAAA,KAAA,CAAA;AAAA,OAAA;AACA,KA3GA;AA4GA,IAAA,oBA5GA,gCA4GA,KA5GA,EA4GA;AACA,UAAA,KAAA,CAAA,OAAA,EAAA;AACA;AACA;;AACA,WAAA,aAAA,GAAA;AAAA,QAAA,CAAA,EAAA,KAAA,CAAA,OAAA;AAAA,QAAA,CAAA,EAAA,KAAA,CAAA;AAAA,OAAA;AACA,KAjHA;AAkHA;AACA,IAAA,oBAnHA,gCAmHA,IAnHA,EAmHA;AACA,UAAA,SAAA,GAAA,IAAA,CAAA,KAAA,GAAA,CAAA;AACA,UAAA,UAAA,GAAA,IAAA,CAAA,MAAA,GAAA,CAAA;AACA,UAAA,GAAA,GAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,SAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA;AAAA,OAAA;AACA,UAAA,IAAA,GAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA;AAAA,OAAA;AACA,UAAA,MAAA,GAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,SAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA;AAAA,OAAA;AACA,UAAA,KAAA,GAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA;AAAA,QAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA;AAAA,OAAA;AACA,aAAA;AAAA,QAAA,IAAA,EAAA,IAAA;AAAA,QAAA,KAAA,EAAA,KAAA;AAAA,QAAA,GAAA,EAAA,GAAA;AAAA,QAAA,MAAA,EAAA;AAAA,OAAA;AACA,KA3HA;AA4HA;AACA,IAAA,eA7HA,6BA6HA;AACA,UAAA,IAAA,GAAA,IAAA,CADA,CAEA;;AACA,UAAA,IAAA,CAAA,aAAA,EAAA;AACA,QAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,QAAA,IAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,kBAAA,CAAA,MAAA;AACA,YAAA,IAAA,GAAA,eAAA,CAAA,CACA;AAAA,UAAA,CAAA,EAAA,IAAA,CAAA,aAAA,CAAA,CAAA;AAAA,UAAA,CAAA,EAAA,IAAA,CAAA,aAAA,CAAA;AAAA,SADA,EAEA;AAAA,UAAA,CAAA,EAAA,IAAA,CAAA,mBAAA,CAAA,CAAA;AAAA,UAAA,CAAA,EAAA,IAAA,CAAA,mBAAA,CAAA;AAAA,SAFA,CAAA,CAAA;AAIA,YAAA,GAAA,GAAA,EAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACA,YAAA,IAAA,GAAA,GAAA,CAAA,MAAA,CAAA,YAAA,EAAA,OAAA,CAAA,QAAA,EAAA,IAAA,CAAA;AACA,QAAA,IAAA,CACA,IADA,CACA,GADA,EACA,IAAA,CAAA,KAAA,CAAA,CADA,EAEA,IAFA,CAEA,GAFA,EAEA,IAAA,CAAA,KAAA,CAAA,CAFA,EAGA,IAHA,CAGA,OAHA,EAGA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAHA,EAIA,IAJA,CAIA,QAJA,EAIA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,CAJA;AAMA,QAAA,IAAA,CAAA,aAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,cAAA,MAAA,GAAA,CACA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA;AAAA,WADA,EAEA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA;AAAA,WAFA,EAGA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA;AAAA,WAHA,EAIA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA;AAAA,WAJA,CAAA;;AAMA,cACA,MAAA,CAAA,KAAA,CAAA,UAAA,KAAA;AAAA,mBAAA,0BAAA,CAAA,KAAA,EAAA,IAAA,CAAA;AAAA,WAAA,CADA,EAEA;AACA;AACA,YAAA,IAAA,CAAA,YAAA,CAAA,IAAA,CAAA,IAAA;AACA;AACA,SAbA;AAcA,QAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,cAAA,MAAA,GAAA,CACA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,OAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA;AAAA,WADA,EAEA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA,YAAA;AAAA,YAAA,CAAA,EAAA,IAAA,CAAA;AAAA,WAFA,CAAA;;AAIA,cACA,MAAA,CAAA,KAAA,CAAA,UAAA,KAAA;AAAA,mBAAA,0BAAA,CAAA,KAAA,EAAA,IAAA,CAAA;AAAA,WAAA,KACA,IAAA,CAAA,kBAAA,CAAA,KAAA,CAAA,UAAA,IAAA;AAAA,mBAAA,IAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA;AAAA,WAAA,CAFA,EAGA;AACA,gBAAA,UAAA,GAAA,IAAA,CAAA,mBAAA,CAAA,MAAA,CACA,UAAA,IAAA;AAAA,qBAAA,IAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA;AAAA,aADA,EAEA,CAFA,CAAA;AAGA,YAAA,IAAA,CAAA,kBAAA,CAAA,IAAA,CAAA,UAAA;AACA;AACA,SAdA;AAeA,OA5CA,MA4CA;AACA;AACA,QAAA,EAAA,CAAA,SAAA,CAAA,mBAAA,EAAA,OAAA,CAAA,QAAA,EAAA,KAAA;AACA;AACA,KAhLA;AAiLA,IAAA,iBAjLA,+BAiLA;AACA,UAAA,IAAA,GAAA,IAAA;AACA,aAAA,IAAA,OAAA,CAAA,UAAA,OAAA,EAAA;AACA,QAAA,IAAA,CAAA,SAAA,CAAA,YAAA;AACA,UAAA,EAAA,CAAA,SAAA,CAAA,qBAAA,EAAA,MAAA,GADA,CAEA;;AACA,UAAA,IAAA,CAAA,KAAA,GAAA,EAAA;AACA,UAAA,IAAA,CAAA,mBAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,gBAAA,cAAA,GAAA,IAAA,CAAA,sBAAA,CACA,IAAA,CAAA,MAAA,CAAA,EADA,EAEA,IAAA,CAAA,MAAA,CAAA,QAFA,CAAA;AAIA,gBAAA,mBAAA,GAAA,IAAA,CAAA,sBAAA,CACA,IAAA,CAAA,WAAA,CAAA,EADA,EAEA,IAAA,CAAA,WAAA,CAAA,QAFA,CAAA;AAIA,gBAAA,MAAA,GAAA;AACA,cAAA,IAAA,EAAA,SADA;AAEA,cAAA,MAAA,EAAA;AAFA,aAAA;;AAIA,gBACA,IAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,UAAA,IAAA;AAAA,qBAAA,IAAA,KAAA,IAAA;AAAA,aAAA,EAAA,MAAA,GAAA,CADA,EAEA;AACA,cAAA,MAAA,GAAA;AACA,gBAAA,IAAA,EAAA,SADA;AAEA,gBAAA,MAAA,EAAA;AAFA,eAAA;AAIA;;AACA,gBAAA,MAAA,GAAA,IAAA,CAAA,OAAA,CACA,cAAA,CAAA,CADA,EAEA,cAAA,CAAA,CAFA,EAGA,mBAAA,CAAA,CAHA,EAIA,mBAAA,CAAA,CAJA,EAKA,IAAA,CAAA,MAAA,CAAA,QALA,EAMA,IAAA,CAAA,WAAA,CAAA,QANA,EAOA,MAAA,CAAA,IAAA,CAAA,IAAA,CAPA,EAQA;AACA,YAAA,IAAA,CAAA,IATA,CAAA;AArBA;AAAA;AAAA;;AAAA;AAgCA,mCAAA,MAAA,CAAA,KAAA,8HAAA;AAAA,oBAAA,IAAA;AACA,gBAAA,IAAA,CAAA,EAAA,CAAA,WAAA,EAAA,YAAA;AACA,kBAAA,EAAA,CAAA,KAAA,CAAA,eAAA;;AACA,sBAAA,IAAA,CAAA,eAAA,EAAA;AACA,oBAAA,IAAA,CAAA,cAAA,CAAA,IAAA;AACA,mBAFA,MAEA;AACA,wBAAA,KAAA,GAAA,UAAA,CAAA,YAAA;AACA,sBAAA,IAAA,CAAA,eAAA,GAAA,KAAA;AACA,sBAAA,YAAA,CAAA,KAAA,CAAA;AACA,qBAHA,EAGA,GAHA,CAAA;AAIA,oBAAA,IAAA,CAAA,eAAA,GAAA,IAAA;AACA;;AACA,kBAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,kBAAA,IAAA,CAAA,kBAAA,CAAA,MAAA,CACA,CADA,EAEA,IAAA,CAAA,kBAAA,CAAA,MAFA;AAIA,kBAAA,IAAA,CAAA,kBAAA,CAAA,IAAA,CAAA,IAAA;AACA,iBAjBA;AAkBA;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAoDA,oCAAA,MAAA,CAAA,KAAA,mIAAA;AAAA,oBAAA,IAAA;AACA,gBAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA;AACA,kBAAA,OAAA,EAAA,IAAA,CAAA,OADA;AAEA,kBAAA,OAAA,EAAA,IAAA,CAAA,OAFA;AAGA,kBAAA,YAAA,EAAA,IAAA,CAAA,YAHA;AAIA,kBAAA,YAAA,EAAA,IAAA,CAAA,YAJA;AAKA,kBAAA,EAAA,EAAA,IAAA,CAAA;AALA,iBAAA;AAOA;AA5DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6DA,WA7DA;AA8DA,UAAA,OAAA;AACA,SAnEA;AAoEA,OArEA,CAAA;AAsEA,KAzPA;AA0PA,IAAA,WA1PA,yBA0PA;AACA,UAAA,IAAA,GAAA,IAAA;AACA,aAAA,IAAA,OAAA,CAAA,UAAA,OAAA,EAAA;AACA,QAAA,EAAA,CAAA,SAAA,CAAA,eAAA,EAAA,MAAA,GADA,CAGA;;AACA,QAAA,IAAA,CAAA,aAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,UAAA,IAAA,CAAA,UAAA,CACA,IADA,EAEA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,UAAA,IAAA;AAAA,mBAAA,IAAA,KAAA,IAAA;AAAA,WAAA,EAAA,MAAA,GAAA,CAFA;AAIA,SALA;AAOA,QAAA,OAAA;AACA,OAZA,CAAA;AAaA,KAzQA;AA0QA,IAAA,sBA1QA,kCA0QA,MA1QA,EA0QA,iBA1QA,EA0QA;AACA,UAAA,IAAA,GAAA,KAAA,aAAA,CAAA,MAAA,CAAA,UAAA,IAAA;AAAA,eAAA,IAAA,CAAA,EAAA,KAAA,MAAA;AAAA,OAAA,EAAA,CAAA,CAAA;AACA,aAAA,KAAA,oBAAA,CAAA,IAAA,EAAA,iBAAA,CAAA;AACA,KA7QA;AA8QA,IAAA,MA9QA,kBA8QA,OA9QA,EA8QA;AACA,UAAA,GAAA,GAAA,EAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACA,aAAA,GAAA,CAAA,MAAA,CAAA,OAAA,EAAA,YAAA,CAAA;AACA,KAjRA;AAkRA,IAAA,WAlRA,uBAkRA,EAlRA,EAkRA,EAlRA,EAkRA,EAlRA,EAkRA,EAlRA,EAkRA;AACA,UAAA,CAAA,GAAA,KAAA,MAAA,CAAA,GAAA,CAAA;AACA,MAAA,CAAA,CAAA,OAAA,CAAA,WAAA,EAAA,IAAA;AACA,MAAA,MAAA,CAAA,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAAA,EAAA,SAAA,EAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA;AACA,KAtRA;AAuRA,IAAA,OAvRA,mBAuRA,EAvRA,EAuRA,EAvRA,EAuRA,EAvRA,EAuRA,EAvRA,EAuRA,aAvRA,EAuRA,WAvRA,EAuRA,KAvRA,EAuRA,QAvRA,EAuRA;AACA,UAAA,CAAA,GAAA,KAAA,MAAA,CAAA,GAAA,CAAA;AACA,MAAA,CAAA,CAAA,MAAA,CAAA,MAAA,EACA,IADA,CACA,MADA,EACA,SADA,EAEA,IAFA,CAEA,GAFA,EAEA,EAAA,GAAA,EAFA,EAGA,IAHA,CAGA,GAHA,EAGA,EAAA,GAAA,EAHA,EAIA,KAJA,CAIA,OAJA,EAIA,KAAA,IAJA,EAKA,KALA,CAKA,QALA,EAKA,KAAA,IALA,EAMA,IANA,CAMA,QANA;AAOA,MAAA,CAAA,CAAA,OAAA,CAAA,YAAA,EAAA,IAAA;AACA,MAAA,KAAA,CACA,CADA,EAEA,EAFA,EAGA,EAHA,EAIA,EAJA,EAKA,EALA,EAMA,aANA,EAOA,WAPA,EAQA,CARA,EASA,KAAA,IAAA,SATA,EAUA,IAVA,CAAA,CAVA,CAsBA;;AACA,aAAA,KAAA,CACA,CADA,EAEA,EAFA,EAGA,EAHA,EAIA,EAJA,EAKA,EALA,EAMA,aANA,EAOA,WAPA,EAQA,CARA,EASA,aATA,EAUA,KAVA,CAAA;AAYA,KA1TA;AA2TA,IAAA,UA3TA,sBA2TA,IA3TA,EA2TA,UA3TA,EA2TA;AACA,UAAA,IAAA,GAAA,IAAA;AACA,UAAA,CAAA,GAAA,IAAA,CAAA,MAAA,CAAA,GAAA,EAAA,IAAA,CAAA,QAAA,EAAA,MAAA,EAAA,OAAA,CAAA,MAAA,EAAA,IAAA,CAAA;AAEA,MAAA,IAAA,CAAA,MAAA,GAAA,IAAA,CAAA,MAAA;AACA,MAAA,IAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,EAAA,UAAA;AAEA,UAAA,IAAA,GAAA,EAAA,CACA,IADA,GAEA,EAFA,CAEA,OAFA,EAEA,YAAA;AACA;AACA,YAAA,gBAAA,GACA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,UAAA,IAAA;AAAA,iBAAA,IAAA,KAAA,IAAA;AAAA,SAAA,EAAA,MAAA,KAAA,CADA;;AAEA,YAAA,gBAAA,EAAA;AACA,UAAA,IAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,kBAAA,CAAA,MAAA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AAEA,YAAA,IAAA,CAAA,WAAA,EAAA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,UAAA,IAAA,CAAA,QAAA,CAAA,IAAA;AACA,SAHA,MAGA;AACA,cAAA,KAAA,GAAA,UAAA,CAAA,YAAA;AACA,YAAA,IAAA,CAAA,WAAA,GAAA,KAAA;AACA,YAAA,YAAA,CAAA,KAAA,CAAA;AACA,WAHA,EAGA,GAHA,CAAA;AAIA,UAAA,IAAA,CAAA,WAAA,GAAA,IAAA;AACA;AACA,OAtBA,EAuBA,EAvBA,CAuBA,MAvBA;AAAA;AAAA;AAAA;AAAA,8BAuBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBACA,IAAA,CAAA,QADA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAKA,gBAAA,IALA,GAKA,UAAA,CAAA,QAAA,CAAA,cAAA,CAAA,KAAA,EAAA,KAAA,CAAA,IAAA,IAAA,CAAA,CALA;AAAA;AAAA;AAAA;AAAA;;AAMA,kCAAA,IAAA,CAAA,YAAA,2HAAA;AAAA,kBAAA,WAAA;AACA,kBAAA,WAAA,CAAA,CAAA,IAAA,EAAA,CAAA,KAAA,CAAA,EAAA,GAAA,IAAA;AACA,kBAAA,WAAA,CAAA,CAAA,IAAA,EAAA,CAAA,KAAA,CAAA,EAAA,GAAA,IAAA;AACA;;AATA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAWA,gBAAA,EAAA,CAAA,SAAA,CAAA,oBAAA,EAAA,MAAA;AACA,gBAAA,IAZA,GAYA,IAAA,CAAA,mBAAA,EAZA;AAaA,gBAAA,OAbA,GAaA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,IAAA,EAAA,IAAA,EAbA;AAcA,gBAAA,OAdA,GAcA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAA,IAAA,EAAA,IAAA,EAdA;AAeA,gBAAA,IAAA,CAAA,aAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,sBACA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,UAAA,WAAA;AAAA,2BAAA,WAAA,KAAA,IAAA;AAAA,mBAAA,EACA,MADA,KACA,CAFA,EAGA;AACA,wBAAA,IAAA,CAAA,CAAA,KAAA,OAAA,EAAA;AACA;AACA,0BAAA,IAAA,CAAA,CAAA,GAAA,OAAA,EAAA;AACA,wBAAA,IAAA,CAAA,WAAA,CACA,IAAA,CAAA,CADA,EAEA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,MAFA,EAGA,OAHA,EAIA,OAJA;AAMA,uBAPA,MAOA;AACA,wBAAA,IAAA,CAAA,WAAA,CACA,OADA,EAEA,OAAA,GAAA,IAAA,CAAA,MAFA,EAGA,IAAA,CAAA,CAHA,EAIA,IAAA,CAAA,CAJA;AAMA;AACA;;AACA,wBAAA,IAAA,CAAA,CAAA,KAAA,OAAA,EAAA;AACA;AACA,0BAAA,IAAA,CAAA,CAAA,GAAA,OAAA,EAAA;AACA,wBAAA,IAAA,CAAA,WAAA,CACA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KADA,EAEA,IAAA,CAAA,CAFA,EAGA,OAHA,EAIA,OAJA;AAMA,uBAPA,MAOA;AACA,wBAAA,IAAA,CAAA,WAAA,CACA,OAAA,GAAA,IAAA,CAAA,KADA,EAEA,OAFA,EAGA,IAAA,CAAA,CAHA,EAIA,IAAA,CAAA,CAJA;AAMA;AACA;AACA;AACA,iBA1CA;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAvBA,IAkFA,EAlFA,CAkFA,KAlFA,EAkFA,YAAA;AACA,QAAA,EAAA,CAAA,SAAA,CAAA,oBAAA,EAAA,MAAA;AADA;AAAA;AAAA;;AAAA;AAEA,gCAAA,IAAA,CAAA,YAAA,mIAAA;AAAA,gBAAA,WAAA;AACA,YAAA,WAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,WAAA,CAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA,YAAA,WAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,KAAA,CAAA,WAAA,CAAA,CAAA,IAAA,EAAA,IAAA,EAAA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA,OAxFA,CAAA;AAyFA,MAAA,CAAA,CAAA,IAAA,CAAA,IAAA;AACA,MAAA,CAAA,CAAA,EAAA,CAAA,WAAA,EAAA,YAAA;AACA;AACA,YAAA,CAAA,EAAA,CAAA,KAAA,CAAA,OAAA,EAAA;AACA;AACA;;AACA,YAAA,gBAAA,GACA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,UAAA,IAAA;AAAA,iBAAA,IAAA,KAAA,IAAA;AAAA,SAAA,EAAA,MAAA,KAAA,CADA;;AAEA,YAAA,gBAAA,EAAA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,IAAA,CAAA,IAAA;AACA,SAFA,MAEA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,IAAA,CAAA,YAAA,CAAA,OAAA,CAAA,IAAA,CAAA,EAAA,CAAA;AACA;AACA,OAZA;AAcA,UAAA,UAAA,GAAA,EAAA;AACA,UAAA,iBAAA,GAAA,KAAA,oBAAA,CAAA,IAAA,CAAA;;AAhHA,iCAiHA,QAjHA;AAkHA,YAAA,eAAA,GAAA,iBAAA,CAAA,QAAA,CAAA;AACA,YAAA,SAAA,GAAA,CAAA,CACA,MADA,CACA,QADA,EAEA,IAFA,CAEA,IAFA,EAEA,eAAA,CAAA,CAFA,EAGA,IAHA,CAGA,IAHA,EAGA,eAAA,CAAA,CAHA,EAIA,IAJA,CAIA,GAJA,EAIA,CAJA,EAKA,IALA,CAKA,OALA,EAKA,WALA,CAAA;AAMA,QAAA,SAAA,CACA,EADA,CACA,WADA,EACA,YAAA;AACA,UAAA,EAAA,CAAA,KAAA,CAAA,eAAA;;AACA,cAAA,IAAA,CAAA,IAAA,KAAA,KAAA,IAAA,IAAA,CAAA,QAAA,EAAA;AACA;AACA;;AACA,UAAA,IAAA,CAAA,cAAA,CAAA,MAAA,GAAA,IAAA;AACA,UAAA,IAAA,CAAA,cAAA,CAAA,cAAA,GAAA,QAAA;AACA,SARA,EASA,EATA,CASA,SATA,EASA,YAAA;AACA,UAAA,EAAA,CAAA,KAAA,CAAA,eAAA;;AACA,cAAA,IAAA,CAAA,cAAA,CAAA,MAAA,EAAA;AACA,gBAAA,IAAA,CAAA,cAAA,CAAA,MAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA,EAAA;AACA;AACA,kBAAA,MAAA,GAAA,CAAA,IAAA,IAAA,EAAA;AACA,kBAAA,IAAA,GAAA;AACA,gBAAA,MAAA,EAAA;AACA,kBAAA,EAAA,EAAA,IAAA,CAAA,cAAA,CAAA,MAAA,CAAA,EADA;AAEA,kBAAA,QAAA,EAAA,IAAA,CAAA,cAAA,CAAA;AAFA,iBADA;AAKA,gBAAA,WAAA,EAAA;AACA,kBAAA,EAAA,EAAA,IAAA,CAAA,EADA;AAEA,kBAAA,QAAA,EAAA;AAFA,iBALA;AASA,gBAAA,EAAA,EAAA,MATA;AAUA,gBAAA,IAAA,EAAA,MAVA;AAWA,gBAAA,IAAA,EAAA;AAXA,eAAA;AAaA,cAAA,IAAA,CAAA,mBAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AACA,YAAA,IAAA,CAAA,cAAA,CAAA,MAAA,GAAA,IAAA;AACA,YAAA,IAAA,CAAA,cAAA,CAAA,cAAA,GAAA,IAAA;AACA;AACA,SAjCA,EAkCA,EAlCA,CAkCA,WAlCA,EAkCA,YAAA;AACA,UAAA,SAAA,CAAA,OAAA,CAAA,QAAA,EAAA,IAAA;AACA,SApCA,EAqCA,EArCA,CAqCA,UArCA,EAqCA,YAAA;AACA,UAAA,SAAA,CAAA,OAAA,CAAA,QAAA,EAAA,KAAA;AACA,SAvCA;AAwCA,QAAA,UAAA,CAAA,IAAA,CAAA,SAAA;AAjKA;;AAiHA,WAAA,IAAA,QAAA,IAAA,iBAAA,EAAA;AAAA,cAAA,QAAA;AAiDA;;AACA,MAAA,CAAA,CAAA,EAAA,CAAA,WAAA,EAAA,YAAA;AACA,QAAA,UAAA,CAAA,OAAA,CAAA,UAAA,IAAA;AAAA,iBAAA,IAAA,CAAA,OAAA,CAAA,QAAA,EAAA,IAAA,CAAA;AAAA,SAAA;AACA,OAFA,EAEA,EAFA,CAEA,UAFA,EAEA,YAAA;AACA,QAAA,UAAA,CAAA,OAAA,CAAA,UAAA,IAAA;AAAA,iBAAA,IAAA,CAAA,OAAA,CAAA,QAAA,EAAA,KAAA,CAAA;AAAA,SAAA;AACA,OAJA;AAKA,KAneA;AAoeA,IAAA,mBApeA,iCAoeA;AACA,UAAA,MAAA,GAAA,KAAA,YAAA,CAAA,GAAA,CAAA,UAAA,IAAA;AAAA,eAAA;AACA,UAAA,CAAA,EAAA,IAAA,CAAA,CADA;AAEA,UAAA,CAAA,EAAA,IAAA,CAAA;AAFA,SAAA;AAAA,OAAA,CAAA;AAIA,MAAA,MAAA,CAAA,IAAA,OAAA,MAAA,qBACA,KAAA,YAAA,CAAA,GAAA,CAAA,UAAA,IAAA;AAAA,eAAA;AACA,UAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA,KADA;AAEA,UAAA,CAAA,EAAA,IAAA,CAAA,CAAA,GAAA,IAAA,CAAA;AAFA,SAAA;AAAA,OAAA,CADA,EAAA;AAMA,aAAA,eAAA,CAAA,MAAA,CAAA;AACA,KAhfA;AAifA,IAAA,IAjfA,kBAifA;AACA,UAAA,KAAA,QAAA,EAAA;AACA;AACA;;AACA,WAAA,KAAA,CAAA,MAAA,EAAA,KAAA,aAAA,EAAA,KAAA,mBAAA;AACA,KAtfA;AAufA,IAAA,MAvfA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAwfA,KAAA,QAxfA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,sBA2fA,KAAA,kBAAA,CAAA,MAAA,GAAA,CA3fA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AA4fA,kCAAA,KAAA,kBAAA,2HAAA;AAAA,kBAAA,IAAA;AACA,uBAAA,gBAAA,CAAA,IAAA;AACA;;AA9fA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AA+fA,qBAAA,kBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,kBAAA,CAAA,MAAA;;AA/fA;AAAA,sBAigBA,KAAA,YAAA,CAAA,MAAA,GAAA,CAjgBA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAkgBA,kCAAA,KAAA,YAAA,2HAAA;AAAA,kBAAA,IAAA;AACA,uBAAA,UAAA,CAAA,IAAA;AACA;;AApgBA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAqgBA,qBAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,KAAA,YAAA,CAAA,MAAA;;AArgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAwgBA,IAAA,UAxgBA,sBAwgBA,IAxgBA,EAwgBA;AACA,UAAA,WAAA,GAAA,KAAA,mBAAA,CAAA,MAAA,CACA,UAAA,IAAA;AAAA,eAAA,IAAA,CAAA,MAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA,IAAA,IAAA,CAAA,WAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA;AAAA,OADA,CAAA;AADA;AAAA;AAAA;;AAAA;AAIA,8BAAA,WAAA,mIAAA;AAAA,cAAA,UAAA;AACA,eAAA,mBAAA,CAAA,MAAA,CACA,KAAA,mBAAA,CAAA,OAAA,CAAA,UAAA,CADA,EAEA,CAFA;AAIA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUA,WAAA,aAAA,CAAA,MAAA,CAAA,KAAA,aAAA,CAAA,OAAA,CAAA,IAAA,CAAA,EAAA,CAAA;AACA,KAnhBA;AAohBA,IAAA,gBAphBA,4BAohBA,IAphBA,EAohBA;AACA,UAAA,KAAA,GAAA,KAAA,mBAAA,CAAA,OAAA,CAAA,IAAA,CAAA;AACA,WAAA,mBAAA,CAAA,MAAA,CAAA,KAAA,EAAA,CAAA;AACA,KAvhBA;AAwhBA,IAAA,eAxhBA,2BAwhBA,CAxhBA,EAwhBA,CAxhBA,EAwhBA;AACA,UAAA,KAAA,YAAA,CAAA,MAAA,GAAA,CAAA,IAAA,CAAA,KAAA,QAAA,EAAA;AAAA;AAAA;AAAA;;AAAA;AACA,gCAAA,KAAA,YAAA,mIAAA;AAAA,gBAAA,IAAA;AACA,YAAA,IAAA,CAAA,CAAA,IAAA,CAAA;AACA,YAAA,IAAA,CAAA,CAAA,IAAA,CAAA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA,KA/hBA;AAgiBA,IAAA,IAhiBA,kBAgiBA;AACA,UAAA,IAAA,GAAA,IAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,aAAA,CAAA,MAAA;AACA,MAAA,IAAA,CAAA,mBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,mBAAA,CAAA,MAAA;AACA,MAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAAA,UAAA,IAAA,EAAA;AACA,YAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IAAA,CAAA;AACA,QAAA,OAAA,CAAA,KAAA,GAAA,OAAA,CAAA,KAAA,IAAA,GAAA;AACA,QAAA,OAAA,CAAA,MAAA,GAAA,OAAA,CAAA,MAAA,IAAA,GAAA;AACA,QAAA,IAAA,CAAA,aAAA,CAAA,IAAA,CAAA,OAAA;AACA,OALA;AAMA,MAAA,IAAA,CAAA,WAAA,CAAA,OAAA,CAAA,UAAA,UAAA,EAAA;AACA,QAAA,IAAA,CAAA,mBAAA,CAAA,IAAA,CAAA,IAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,CAAA,UAAA,CAAA,CAAA;AACA,OAFA;AAGA;AA7iBA,GAhEA;AA+mBA,EAAA,OA/mBA,qBA+mBA;AACA,QAAA,IAAA,GAAA,IAAA;AACA,IAAA,IAAA,CAAA,IAAA,GAFA,CAGA;;AACA,IAAA,QAAA,CAAA,SAAA,GAAA,UAAA,KAAA,EAAA;AACA,cAAA,KAAA,CAAA,OAAA;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,eAAA,CAAA,CAAA,EAAA,EAAA,CAAA;AACA;;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,eAAA,CAAA,CAAA,EAAA,CAAA,EAAA;AACA;;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,eAAA,CAAA,EAAA,EAAA,CAAA;AACA;;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,eAAA,CAAA,CAAA,EAAA,EAAA;AACA;;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,UAAA,IAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,kBAAA,CAAA,MAAA;AACA;;AACA,aAAA,EAAA;AACA,cAAA,QAAA,CAAA,aAAA,KAAA,QAAA,CAAA,cAAA,CAAA,OAAA,CAAA,EAAA;AAAA;;AACA,YAAA,IAAA,CAAA,YAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,YAAA,CAAA,MAAA;AACA,YAAA,IAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,CAAA,EAAA,IAAA,CAAA,kBAAA,CAAA,MAAA;;AACA,kCAAA,IAAA,CAAA,YAAA,EAAA,IAAA,8CAAA,IAAA,CAAA,aAAA;;AACA,qCAAA,IAAA,CAAA,kBAAA,EAAA,IAAA,iDAAA,IAAA,CAAA,mBAAA;;AACA,YAAA,KAAA,CAAA,cAAA;AACA;;AACA;;AACA,aAAA,EAAA;AACA,UAAA,IAAA,CAAA,MAAA;AACA;;AACA;AACA;AA9BA;AAgCA,KAjCA;AAkCA,GArpBA;AAspBA,EAAA,OAtpBA,qBAspBA,CAAA,CAtpBA;AAupBA,EAAA,QAAA,EAAA;AACA,IAAA,gBADA,8BACA;AAAA;AAAA;AAAA;;AAAA;AACA,8BAAA,KAAA,aAAA,mIAAA;AAAA,cAAA,IAAA;AACA,cAAA,iBAAA,GAAA,KAAA,oBAAA,CAAA,IAAA,CAAA;;AACA,eAAA,IAAA,IAAA,IAAA,iBAAA,EAAA;AACA,gBAAA,KAAA,GAAA,iBAAA,CAAA,IAAA,CAAA;;AACA,gBACA,IAAA,CAAA,KAAA,CACA,KAAA,CAAA,CAAA,GAAA,KAAA,mBAAA,CAAA,CADA,EAEA,KAAA,CAAA,CAAA,GAAA,KAAA,mBAAA,CAAA,CAFA,IAGA,EAJA,EAKA;AACA,qBAAA;AAAA,gBAAA,QAAA,EAAA,IAAA;AAAA,gBAAA,IAAA,EAAA;AAAA,eAAA;AACA;AACA;AACA;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeA,aAAA,IAAA;AACA,KAjBA;AAkBA,IAAA,iBAlBA,+BAkBA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,cACA,IADA;AAEA,cAAA,QAAA,GAAA,qBAAA,CACA,IAAA,CAAA,OADA,EAEA,IAAA,CAAA,OAFA,EAGA,IAAA,CAAA,YAHA,EAIA,IAAA,CAAA,YAJA,EAKA,KAAA,CAAA,mBAAA,CAAA,CALA,EAMA,KAAA,CAAA,mBAAA,CAAA,CANA,CAAA;;AAQA,cACA,QAAA,GAAA,CAAA,IACA,OAAA,CACA,IAAA,CAAA,OAAA,GAAA,CADA,EAEA,IAAA,CAAA,YAAA,GAAA,CAFA,EAGA,KAAA,CAAA,mBAAA,CAAA,CAHA,CADA,IAMA,OAAA,CACA,IAAA,CAAA,OAAA,GAAA,CADA,EAEA,IAAA,CAAA,YAAA,GAAA,CAFA,EAGA,KAAA,CAAA,mBAAA,CAAA,CAHA,CAPA,EAYA;AACA,gBAAA,WAAA,GAAA,KAAA,CAAA,mBAAA,CAAA,MAAA,CACA,UAAA,IAAA;AAAA,qBAAA,IAAA,CAAA,EAAA,KAAA,IAAA,CAAA,EAAA;AAAA,aADA,CAAA;;AAGA;AAAA,iBAAA,WAAA,CAAA,MAAA,GAAA,CAAA,GAAA,WAAA,CAAA,CAAA,CAAA,GAAA;AAAA;AACA;AA3BA;;AACA,+BAAA,KAAA,KAAA,wIAAA;AAAA;;AAAA;AA2BA;AA5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6BA,aAAA,IAAA;AACA,KAhDA;AAiDA,IAAA,MAjDA,oBAiDA;AACA;AACA,UAAA,KAAA,cAAA,CAAA,MAAA,IAAA,KAAA,gBAAA,EAAA;AACA,eAAA,WAAA;AACA;;AACA,UAAA,KAAA,iBAAA,IAAA,IAAA,EAAA;AACA,eAAA,SAAA;AACA;;AACA,aAAA,IAAA;AACA;AA1DA,GAvpBA;AAmtBA,EAAA,KAAA,EAAA;AACA,IAAA,aAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,WAAA;AACA,aAAA,iBAAA;AACA;AANA,KADA;AASA,IAAA,mBAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,iBAAA;AACA;AALA,KATA;AAgBA,IAAA,aAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,eAAA;AACA;AALA,KAhBA;AAuBA,IAAA,YAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,WAAA;AACA;AALA,KAvBA;AA8BA,IAAA,kBAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,iBAAA;AACA;AALA,KA9BA;AAqCA,IAAA,mBAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,YAAA,KAAA,aAAA,EAAA;AACA,eAAA,eAAA;AACA;AACA;AAPA,KArCA;AA8CA,IAAA,cAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,iBAAA;AACA;AALA,KA9CA;AAqDA,IAAA,KAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,IAAA;AACA;AALA,KArDA;AA4DA,IAAA,WAAA,EAAA;AACA,MAAA,SAAA,EAAA,IADA;AAEA,MAAA,IAAA,EAAA,IAFA;AAGA,MAAA,OAHA,qBAGA;AACA,aAAA,IAAA;AACA;AALA;AA5DA;AAntBA,CAAA","sourcesContent":["<template>\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{\n      width: isNaN(width) ? width : width + 'px',\n      height: isNaN(height) ? height : height + 'px',\n      cursor: cursor,\n    }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @dblclick=\"handleChartDblClick($event)\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\"\n  >\n    <span id=\"position\" class=\"unselectable\">\n      <!-- 右上の座標 -->\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span>\n    <svg id=\"svg\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n  </div>\n</template>\n<style src=\"./index.css\"></style>\n<script>\nimport { line2, lineTo } from \"../../utils/svg\";\nimport * as d3 from \"d3\";\nimport {\n  between,\n  distanceOfPointToLine,\n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"../../utils/math\";\nimport render from \"./render\";\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    nodes: {\n      type: Array,\n      default: () => [\n        { id: 1, x: 140, y: 270, name: \"Start\", thumbnail: \"start\" },\n        { id: 2, x: 540, y: 270, name: \"End\", thumbnail: \"end\" },\n      ],\n    },\n    connections: {\n      type: Array,\n      default: () => [\n        {\n          source: { id: 1, position: \"right\" },\n          destination: { id: 2, position: \"left\" },\n          id: 1,\n          type: \"pass\",\n        },\n      ],\n    },\n    width: {\n      type: [String, Number],\n      // default: 800,\n      // default: '60%',\n      default: '100%',\n    },\n    height: {\n      type: [String, Number],\n      // default: 600,\n      default: '100%',\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    render: {\n      type: Function,\n      default: render,\n    },\n  },\n  data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       *  of all internalConnections\n       */\n      lines: [],\n    };\n  },\n  methods: {\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.internalNodes.push(node);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      // @editnode=\"handleEditNode\"に引数nodeを渡して実行\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            let tempId = +new Date();\n            let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              type: \"pass\",\n              name: \"Pass\",\n            };\n            this.internalConnections.push(conn);\n          }\n        }\n        // 初期化\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      // actualX = ページの左上からの座標 - チャートの左側までの座標 - windowを正の方向にスクロースしている座標;\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n\n      // connectionを接続中ならば\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        d3.selectAll(\"#svg .connector\").classed(\"active\", true);\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          destinationPosition\n        );\n      }\n    },\n    handleChartDblClick(event) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"dblclick\", { x: event.offsetX, y: event.offsetY });\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    // ここでコネクターの位置を調整できる\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    // chart上で選択範囲を描画\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n        let svg = d3.select(\"#svg\");\n        let rect = svg.select(\".selection\").classed(\"active\", true);\n        rect\n          .attr(\"x\", edge.start.x)\n          .attr(\"y\", edge.start.y)\n          .attr(\"width\", edge.end.x - edge.start.x)\n          .attr(\"height\", edge.end.y - edge.start.y);\n\n        that.internalNodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge))\n          ) {\n            // currentNodes = 選択nodes\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.internalConnections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        // 選択されたときはactiveクラスが付与される\n        d3.selectAll(\"#svg > .selection\").classed(\"active\", false);\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          d3.selectAll(\"#svg > g.connection\").remove();\n          // render lines\n          that.lines = [];\n          that.internalConnections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position,\n            );\n            let colors = {\n              pass: \"#52c41a\",\n              reject: \"red\",\n            };\n            if (\n              that.currentConnections.filter((item) => item === conn).length > 0\n            ) {\n              colors = {\n                pass: \"#12640a\",\n                reject: \"darkred\",\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              colors[conn.type],\n              // 追加\n              conn.name\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function () {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(\n                  0,\n                  that.currentConnections.length\n                );\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        d3.selectAll(\"#svg > g.node\").remove();\n\n        // render nodes\n        that.internalNodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.internalNodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, color, connName) {\n      let g = this.append(\"g\");\n      g.append('text')\n        .attr(\"fill\", \"#7CF8FD\")\n        .attr(\"x\", x2 + 10)\n        .attr(\"y\", y2 - 40)\n        .style(\"width\", 10 + \"px\")\n        .style(\"height\", 10 + \"px\")\n        .text(connName)\n      g.classed(\"connection\", true);\n      line2(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        1,\n        color || \"#a3a3a3\",\n        true\n      );\n      // a 5px cover to make mouse operation conveniently\n      return line2(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n\n      node.render = that.render;\n      node.render(g, node, isSelected);\n\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            currentNode.x += d3.event.dx / zoom;\n            currentNode.y += d3.event.dy / zoom;\n          }\n\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.internalNodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            if (node.type === \"end\" || that.readonly) {\n              return;\n            }\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = +new Date();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  type: \"pass\",\n                  name: \"Pass\",\n                };\n                that.internalConnections.push(conn);\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.internalNodes, this.internalConnections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.internalConnections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.internalConnections.splice(\n          this.internalConnections.indexOf(connection),\n          1\n        );\n      }\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection(conn) {\n      let index = this.internalConnections.indexOf(conn);\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          node.x += x;\n          node.y += y;\n        }\n      }\n    },\n    init() {\n      let that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach((node) => {\n        let newNode = Object.assign({}, node);\n        newNode.width = newNode.width || 400;\n        newNode.height = newNode.height || 200;\n        that.internalNodes.push(newNode);\n      });\n      that.connections.forEach((connection) => {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    },\n  },\n  mounted() {\n    let that = this;\n    that.init();\n    // 十字キーによる移動\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.internalNodes);\n            that.currentConnections.push(...that.internalConnections);\n            event.preventDefault();\n          }\n          break;\n        case 46:\n          that.remove();\n          break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    hoveredConnector() {\n      for (const node of this.internalNodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.internalConnections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      // connectorをhover時とコネクター選択時は十字キーになる\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    internalNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    internalConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n  },\n};\n</script>\n"],"sourceRoot":"src/components/flowchart"}]}